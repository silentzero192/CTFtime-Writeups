

# This file was *autogenerated* from the file sample.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_0 = Integer(0); _sage_const_1en30 = RealNumber('1e-30'); _sage_const_81 = Integer(81); _sage_const_9 = Integer(9); _sage_const_8 = Integer(8); _sage_const_16 = Integer(16); _sage_const_25 = Integer(25); _sage_const_33 = Integer(33); _sage_const_42 = Integer(42); _sage_const_50 = Integer(50); _sage_const_59 = Integer(59); _sage_const_67 = Integer(67); _sage_const_6 = Integer(6); _sage_const_256 = Integer(256); _sage_const_31 = Integer(31); _sage_const_300 = Integer(300); _sage_const_5 = Integer(5); _sage_const_10 = Integer(10); _sage_const_77 = Integer(77); _sage_const_125 = Integer(125); _sage_const_0xFF = Integer(0xFF); _sage_const_48 = Integer(48); _sage_const_32 = Integer(32); _sage_const_126 = Integer(126); _sage_const_1000000 = Integer(1000000)#!/usr/bin/env sage
from Crypto.Util.number import bytes_to_long, long_to_bytes
from sage.all import RealField, sqrt, round

def inverse_step(x_next, r, phi):
    # x_next, r, phi are in RealField
    A = x_next - (_sage_const_1  - r) * phi
    disc = r**_sage_const_2  * (A**_sage_const_2  + _sage_const_1  - _sage_const_2 *r)
    if disc < _sage_const_0 :
        return None
    sqrt_disc = r * sqrt(A**_sage_const_2  + _sage_const_1  - _sage_const_2 *r)  # note: this is r * sqrt(...), not sqrt(disc)
    denom = _sage_const_1  - _sage_const_2 *r
    # Two candidates
    u1 = (A*(_sage_const_1 -r) + sqrt_disc) / denom
    u2 = (A*(_sage_const_1 -r) - sqrt_disc) / denom
    # Check which one is correct by forward step (approximately)
    for u in [u1, u2]:
        if abs(r*sqrt(u**_sage_const_2 +_sage_const_1 ) + (_sage_const_1 -r)*(u+phi) - x_next) < _sage_const_1en30 :
            return u
    return None

def inverse_spiral(y, phi, iterations=_sage_const_81 ):
    x = y
    for i in reversed(range(iterations)):
        r = i / iterations
        x = inverse_step(x, r, phi)
        if x is None:
            return None
    return x

def main():
    masked = "?7086013?3756162?51694057?5285516?54803756?9202316?39221780?4895755?50591029"
    n = len(masked)  # 76
    k = _sage_const_9   # number of '?'
    # Positions of '?'
    unknown_positions = [_sage_const_0 ,_sage_const_8 ,_sage_const_16 ,_sage_const_25 ,_sage_const_33 ,_sage_const_42 ,_sage_const_50 ,_sage_const_59 ,_sage_const_67 ]
    
    # Known digits: build a list with None for unknown
    digits = list(masked)
    for i in range(n):
        if digits[i] == '?':
            digits[i] = None
        else:
            digits[i] = int(digits[i])
    
    # We assume first unknown digit is 6 (position 0)
    digits[_sage_const_0 ] = _sage_const_6 
    
    # Now unknown positions except 0: [8,16,25,33,42,50,59,67]
    # We'll iterate over 10^8 possibilities
    unknown_indices = [_sage_const_8 ,_sage_const_16 ,_sage_const_25 ,_sage_const_33 ,_sage_const_42 ,_sage_const_50 ,_sage_const_59 ,_sage_const_67 ]
    
    # Precompute known part of flag integer
    # flag = bytes_to_long(b'0xL4ugh{?????????????????????}')
    # We know first 8 bytes and last byte
    known_prefix = b'0xL4ugh{'
    known_suffix = b'}'
    # Compute K' = sum_{i=0}^{7} byte_i * 256^(31-i) + 125 * 256^0
    K = _sage_const_0 
    for i, b in enumerate(known_prefix):
        K += b * (_sage_const_256 **(_sage_const_31 -i))
    K += ord(known_suffix)  # 125
    print("K =", K)
    
    # Expected high byte: 48 (most significant byte)
    # Expected low byte: 125
    
    # Precision
    prec = _sage_const_300 
    R = RealField(prec)
    phi = R((_sage_const_1 +sqrt(_sage_const_5 ))/_sage_const_2 )
    
    # Decimal point position: after 2 digits
    dp = _sage_const_2 
    
    count = _sage_const_0 
    # Iterate over 8 unknown digits
    for vals in cartesian_product([range(_sage_const_10 ) for _ in range(_sage_const_8 )]):
        # Assign digits
        for idx, val in zip(unknown_indices, vals):
            digits[idx] = val
        # Build digit string
        digit_str = ''.join(str(d) for d in digits)
        # Insert decimal point after dp digits
        y_str = digit_str[:dp] + '.' + digit_str[dp:]
        y = R(y_str)
        # Invert spiral
        x = inverse_spiral(y, phi)
        if x is None or x <= _sage_const_0  or x >= _sage_const_1 :
            continue
        # Compute flag integer
        flen = _sage_const_77 
        flag_int = round(x * R(_sage_const_10 )**flen)
        flag_int = Integer(flag_int)
        # Check low byte
        if flag_int % _sage_const_256  != _sage_const_125 :
            continue
        # Check high byte
        high_byte = (flag_int >> (_sage_const_31 *_sage_const_8 )) & _sage_const_0xFF 
        if high_byte != _sage_const_48 :
            continue
        # Convert to bytes
        flag_bytes = long_to_bytes(flag_int)
        if len(flag_bytes) != _sage_const_32 :
            # Maybe adjust length
            continue
        # Check prefix and suffix
        if not (flag_bytes.startswith(known_prefix) and flag_bytes.endswith(known_suffix)):
            continue
        # Check all bytes printable
        if all(_sage_const_32  <= b <= _sage_const_126  for b in flag_bytes):
            print("Found flag:", flag_bytes)
            return
        count += _sage_const_1 
        if count % _sage_const_1000000  == _sage_const_0 :
            print("Processed", count)
    
if __name__ == "__main__":
    main()

